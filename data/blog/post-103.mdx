---
title: 爆火的 OpenClaw 依赖的极简 Agent 框架 Pi
date: 2026-02-22T13:12:07Z
slug: post-103
author: coderPerseus：https://github.com/coderPerseus
tags: ["AI","Agent"]
---

大家好，我是 luckySnail，今天分享一篇文章，讲述爆火的 OpenClaw 依赖的 Agent 框架 [Pi-mono](https://github.com/badlogic/pi-mono) , 



> 原文地址 ：[https://lucumr.pocoo.org/2026/1/31/pi/](https://lucumr.pocoo.org/2026/1/31/pi/)
>
> _作者：Armin Ronacher_
>
> _写作日期：2026年1月31日_
>
> 翻译：Gemini 3 Pro。如果你需要网页翻译插件，强烈推荐使用「🥥 椰子翻译」
>



如果你这周并非与世隔绝，你应该已经注意到我朋友 Peter 的一个项目在互联网上爆火了。它有很多名字。最近的一个叫 OpenClaw，但在新闻中你可能见过 ClawdBot 或 MoltBot，这取决于你何时读到相关报道。它是一个连接到你所选通信频道的代理，其功能仅仅是运行代码。



你可能不太熟悉的是，OpenClaw 的底层是一个叫做 Pi 的小型编码代理。巧合的是，Pi 目前也是我几乎唯一使用的编码代理。在过去的几周里，我越来越像这个小代理的“托儿”了。最近我在做了一次关于它的演讲后，意识到我还未在这个博客上写过关于 Pi 的文章，所以我觉得有必要提供一些背景信息，解释一下我为何对它如此着迷，以及它与 OpenClaw 的关系。



Pi 是由 Mario Zechner 编写的。不同于 Peter 那种追求“带有疯狂色彩的科幻”风格（注1），Mario 非常脚踏实地。尽管方法不同，但 OpenClaw 和 Pi 遵循同一个理念：大语言模型（LLM）非常擅长编写和运行代码，所以应该拥抱这一点。在某些方面我认为这并非巧合，因为 Peter 去年让我和 Mario 都迷上了这个想法以及代理（agents）。



**Pi 是什么？**

****

Pi 是一个编码代理。市面上有很多编码代理。真的，我认为现在你随便选一个，都能体验到代理编程是什么感觉。在这个博客的评论中，我曾积极评价过 AMP，我之所以对 AMP 有如此强烈的共鸣，原因之一在于它真的感觉像是由那些既沉迷于代理编程，又尝试过多种不同方案以确定哪种有效的人所构建的产品，而不仅仅是围绕它构建一个花哨的 UI。



Pi 对我来说之所以有趣，主要有两个原因：



首先，它有一个极小的核心。它的系统提示词是我所知道的所有代理中最短的，而且它只有四个工具：



读取（Read）、写入（Write）、编辑（Edit）、Bash。



第二点是，它通过提供一个扩展系统弥补了极小核心的不足，该系统还允许扩展将状态持久化到会话中，这非常强大。



还有一个额外的好处：Pi 本身的代码写得非常出色。它不闪烁，不消耗大量内存，不随机崩溃，非常可靠，而且是由一位非常在意软件内涵的人编写的。



Pi 也是一系列小组件的集合，你可以在其上构建你自己的代理。这就是 OpenClaw 的构建方式，也是我构建自己的小型 Telegram 机器人的方式，以及 Mario 构建他的“mom”的方式。如果你想构建自己的代理并连接到某物，只要将 Pi 指向它自己和 mom，它就会为你变出一个来。



**Pi 里没有什么**

为了理解 Pi 里有什么，更重要的是理解 Pi 里没有什么，为什么没有，以及更关键的：为什么将来也不会有。最明显的遗漏是不支持 MCP。它里面没有 MCP 支持。虽然你可以为它构建一个扩展，但你也可以像 OpenClaw 支持 MCP 那样做，即使用 `mcporter`。`mcporter` 通过 CLI 接口或 TypeScript 绑定公开 MCP 调用，也许你的代理可以用它做点什么。也可能不做，我不知道 :)



这并非懒惰导致的遗漏。这源于 Pi 的工作哲学。Pi 的核心理念是，如果你想让代理做一些它目前还不会做的事情，你不需要去下载一个扩展或一项技能之类的东西。你要求代理扩展它自己。它推崇编写代码和运行代码的理念。



这并不意味着你不能下载扩展。它是完全支持的。但相比于必须鼓励你下载别人的扩展，你也可以将你的代理指向一个现有的扩展，比如说，“像那边那个东西一样构建它，但要做成我喜欢的这些修改”。



**为构建 Agent 的元框架**

****

当你观察 Pi 以及作为其扩展的 OpenClaw 在做什么时，你会看到一个软件像粘土一样具有延展性的例子。这实际上对其底层架构设定了某些要求，这些要求在许多方面设定了系统的某些约束，而这些约束确实需要进入核心设计。



例如，Pi 的底层 AI SDK 的编写方式使得一个会话真的可以包含来自许多不同模型提供商的许多不同消息。它认识到会话的可移植性在模型提供商之间是有些受限的，因此它不过分依赖任何无法转移到另一家的模型提供商特定功能集。



第二点是，除了模型消息之外，它还在会话文件中维护自定义消息，这些消息可以被扩展用来存储状态，或者被系统本身用来维护那些根本不发送给 AI 或只发送部分给 AI 的信息。



因为存在这个系统，且扩展状态也可以持久化到磁盘，它内置了热重载功能，以便代理可以编写代码、重载、测试并循环进行，直到你的扩展真正具备功能。它还附带了文档和示例，代理本身可以使用这些来扩展自己。更好的是：Pi 中的会话是树状的。你可以在一个会话中分支并在其中导航，这开启了各种有趣的机会，例如启用一种工作流：进行一个支线任务来修复一个损坏的代理工具，而不会在主会话中浪费上下文。工具修复后，我可以将会话倒回到更早的时候，Pi 会总结另一个分支上发生了什么。



这一切都很重要，因为例如如果你考虑 MCP 是如何工作的，在大多数模型提供商上，MCP 的工具（像任何给 LLM 的工具一样）需要在会话开始时加载到系统上下文或其工具部分。这使得在不破坏整个缓存或让 AI 困惑于之前的调用方式为何不同的情况下，完全重载工具能做什么变得非常困难，甚至不可能。



**上下文之外的工具**

****

Pi 中的扩展可以注册一个工具供 LLM 调用，而且我时不时地发现这很有用。例如，尽管我批评 Beads 的实现方式，但我确实认为给代理访问待办事项列表是一个非常有用的事情。我确实使用一个在本地工作的代理特定问题追踪器，那是我让我的代理自己构建的。因为我也想让代理管理待办事项，在这种特定情况下，我决定给它一个工具而不是一个 CLI。这感觉适合问题的范围，而且目前这是我加载到我的上下文中的唯一额外工具。



但在大多数情况下，我添加到我的代理中的都是技能或 TUI 扩展，以使与代理的协作对我来说更愉快。除了斜杠命令，Pi 扩展可以直接在终端中渲染自定义 TUI 组件：旋转器、进度条、交互式文件选择器、数据表格、预览面板。TUI 足够灵活，Mario 证明了你可以在里面运行《毁灭战士》（Doom）。这虽然不实用，但如果你能运行《毁灭战士》，你肯定能构建一个有用的仪表板或调试界面。



我想重点介绍我的一些扩展，让你了解什么是可能的。虽然你可以原封不动地使用它们，但整个理念实际上是你将你的代理指向一个扩展，并根据你的心意对其进行重新混合。



`/answer`



我不使用计划模式。我鼓励代理提问，这之间会有富有成效的来回互动。但我不喜欢那种如果你给代理一个提问工具就会发生的结构化问答对话。我更喜欢代理自然的散文，中间穿插着解释和图表。



问题在于：在行内回答问题会变得混乱。所以 `/answer` 读取代理的上一个回复，提取所有问题，并将它们重新格式化为一个漂亮的输入框。

![image.png](https://blog-1304565468.cos.ap-shanghai.myqcloud.com/typora/20260222210838.png)

`/todos`



尽管我批评 Beads 的实现，但给代理一个待办事项列表确实非常有用。`/todos` 命令会调出存储在 `.pi/todos` 中的所有条目作为 markdown 文件。代理和我都可以操作它们，会话可以认领任务以将其标记为进行中。

youtube 在线演示：[https://youtu.be/ZcKbzxziA5k?si=5jeP2QFsc4P0ILWu](https://youtu.be/ZcKbzxziA5k?si=5jeP2QFsc4P0ILWu)



`/review`



随着越来越多的代码由代理编写，在代理先审查之前就把未完成的工作扔给人类是没有什么意义的。因为 Pi 会话是树状的，我可以分支进入一个新的审查上下文，获取发现，然后将修复带回主会话。



UI 模仿了 Codex，它提供了易于审查的提交、差异、未提交的更改或远程 PR。提示词关注我关心的事情，所以我能得到我想要的提示（例如：我要求它指出新添加的依赖项）。



`/control`



这是一个我正在试验但不常使用的扩展。它允许一个 Pi 代理向另一个发送提示词。这是一个简单的多代理系统，没有复杂的编排，这对于实验很有用。



`/files`



列出会话中更改或引用的所有文件。你可以在 Finder 中显示它们，在 VS Code 中比较差异，快速查看它们，或在你的提示词中引用它们。Shift+Ctrl+R 会快速查看最近提到的文件，当代理生成 PDF 时这很方便。



其他人也构建了扩展：Nico 的子代理扩展和 interactive-shell，后者让 Pi 可以在一个可观察的 TUI 覆盖层中自主运行交互式 CLI。



**软件构建软件**



这些都只是关于你可以用你的代理做什么的想法。其重点主要在于，这其中没有一样是我写的，它们都是代理根据我的规格说明创建的。我告诉 Pi 制作一个扩展，它就做了。没有 MCP，没有社区技能，什么都没有。别误会，我使用了大量的技能。但它们是由我的“机器”手工制作的，而不是从任何地方下载的。例如，我完全用一个只使用 CDP 的技能替换了我所有用于浏览器自动化的 CLI 或 MCP。这并非因为替代品不起作用或很糟糕，而是因为这样简单且自然。代理维护它自己的功能。



我的代理有不少技能，关键是如果我不需要它们，我会把技能扔掉。例如，我给了它一个技能来读取其他工程师分享的 Pi 会话，这有助于代码审查。或者我有一个技能来帮助代理通过我想要的方式撰写提交信息和提交行为，以及如何更新变更日志。这些最初是斜杠命令，但我目前正在将它们迁移到技能，看看这是否同样有效。我还有一个技能希望能帮助 Pi 使用 `uv` 而不是 `pip`，但我同时也添加了一个自定义扩展来拦截对 `pip` 和 `python` 的调用，以便将它们重定向到 `uv`。



与像 Pi 这样的极简代理一起工作给我的部分魅力在于，它让你亲身体验了使用“构建更多软件的软件”这一理念。将这一点推向极致，就是当你移除 UI 和输出并将其连接到你的聊天时。这就是 OpenClaw 所做的，鉴于其巨大的增长，我真的越来越觉得这将在某种程度上成为我们的未来。





---
此文自动发布于：<a href="https://github.com/coderPerseus/blog/issues/103" target="_blank">github issues</a>
